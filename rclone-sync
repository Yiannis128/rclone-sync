#!/bin/bash

usage() {
    echo "Usage: $0 [options] REMOTE_PATH LOCAL_DIR"
    echo "Options:"
    echo "  -h, --help              Show this help message"
    echo "  --max-delete N          Abort if >N files would be deleted (default: 50, 0=disable)"
    exit 0
}

MAX_DELETE_THRESHOLD=50

while [[ $# -gt 0 && "$1" == -* ]]; do
    case "$1" in
        -h|--help) usage ;;
        --max-delete)
            MAX_DELETE_THRESHOLD="$2"
            shift 2
            ;;
        *) echo "Invalid option: $1" >&2; usage ;;
    esac
done

if [ $# -ne 2 ]; then
    usage
fi

# Configuration
# Periodic sync for remote changes
REMOTE_POLL_PERIOD=20
# Time to wait for local batch changes before applying them
LOCAL_BATCH_DELAY=5
REMOTE_PATH="$1"
LOCAL_DIR="$2"
# Safety: Abort if more than MAX_DELETE_THRESHOLD files would be deleted (protects against accidents/ransomware)
RCLONE_FLAGS="--compare size,modtime,checksum
	--max-delete $MAX_DELETE_THRESHOLD
	--resilient 
	--recover 
	--transfers 4 
	--retries 5 
	--low-level-retries 10 
	--create-empty-src-dirs
	--conflict-resolve newer
	--conflict-loser pathname
	--check-first
	--modify-window 1s
	--verbose"

WORKDIR="$HOME/.cache/rclone/bisync"
# Use base64 encoding to prevent path collisions (e.g., "foo/bar" vs "foo_bar")
SAFE_REMOTE=$(echo -n "$REMOTE_PATH" | base64 -w0 | tr '+/' '-_' | tr -d '=')
SAFE_LOCAL=$(echo -n "$LOCAL_DIR" | base64 -w0 | tr '+/' '-_' | tr -d '=')
PATH1_LST="$WORKDIR/$SAFE_REMOTE..$SAFE_LOCAL.path1.lst"
PATH2_LST="$WORKDIR/$SAFE_REMOTE..$SAFE_LOCAL.path2.lst"
LOCKFILE="/tmp/rclone_bisync_lockfile_${SAFE_REMOTE}_${SAFE_LOCAL}"

# Function to run bisync
run_bisync() {
    rclone bisync "$@" "$REMOTE_PATH" "$LOCAL_DIR"
    if [ $? -eq 0 ]; then
        echo "rclone bisync finished successfully at $(date)"
    else
        echo "rclone bisync failed at $(date)"
    fi
    echo ""
}

# Check if directory existed
if [ -d "$LOCAL_DIR" ]; then
    DIR_EXISTED=true
else
    DIR_EXISTED=false
fi

echo "Config: $RCLONE_FLAGS $REMOTE_PATH $LOCAL_DIR"

mkdir -p "$LOCAL_DIR" || ( echo "Failed to create directory $LOCAL_DIR" && exit 1 )
mkdir -p "$WORKDIR"

echo "Watcher started for $LOCAL_DIR at $(date)"

# Initial sync (must complete before starting background loops)
if [ ! -f "$PATH1_LST" ] || [ ! -f "$PATH2_LST" ] || ! $DIR_EXISTED; then
    echo "First time detected. Running resync preferring remote."
    run_bisync $RCLONE_FLAGS --resync --resync-mode path1
else
    run_bisync $RCLONE_FLAGS
fi

echo "Initial sync complete. Starting background monitoring at $(date)"

(while true; do
    sleep $REMOTE_POLL_PERIOD
    (
        flock -n 99 || exit 1
	echo "Polling for remote changes. Running rclone bisync at $(date)"
        run_bisync $RCLONE_FLAGS
    ) 99>"$LOCKFILE"
done) &
remote_sync_pid=$!
cleanup() {
    echo 'Cleaning up...'
    # Kill background loops
    kill $remote_sync_pid 2>/dev/null
    # Gracefully terminate any running rclone processes (--recover will handle resume)
    pkill -TERM -P $$ rclone 2>/dev/null
    # Kill any remaining child processes
    pkill -P $$ 2>/dev/null
    # Remove lockfile
    rm -f "$LOCKFILE"
}
trap cleanup SIGINT SIGTERM EXIT

# The watching loop using inotifywait
# -m: Monitor continuously
# -r: Recurse into subdirectories
# -e: Events to listen for (modify, create, delete, move)
# Simple debouncing: drain all events, wait for quiet period, then sync
inotifywait -m -r -q -e modify,create,delete,move --format '%w%f' "$LOCAL_DIR" | while true; do
    # Wait for first event
    read -r file || break

    # Drain additional events during batch delay (debouncing)
    while read -r -t $LOCAL_BATCH_DELAY file; do
        : # just drain events
    done

    # All events drained, now sync
    (
        flock -n 99 || exit 1
        echo "Local changes detected. Running rclone bisync at $(date)"
        run_bisync $RCLONE_FLAGS
    ) 99>"$LOCKFILE"
done

